#!/usr/bin/env python3
# Copyright (c) 2018, Arm Limited and Contributors. All rights reserved.
#
# SPDX-License-Identifier: Apache-2.0

"""This script manage application updates."""

import sys
import argparse
import os
import subprocess
import logging
from enum import Enum
import mbl.AppManager as apm
import mbl.AppLifecycleManager as alm

__version__ = "1.0"
APP_STOP_TIMEOUT = 3


class Error(Enum):
    """AppUpdateManager error codes."""

    SUCCESS = 0
    ERR_OPERATION_FAILED = 1
    ERR_GET_CONTAINER_STATUS_FAILED = 2
    ERR_INSTALL_PACKAGE_FAILED = 3
    ERR_STOP_CONTAINER_FAILED = 4
    ERR_RUN_CONTAINER_FAILED = 5
    ERR_GET_APP_ID_FAILED = 6


class AppUpdateManager:
    """Manage application Updates."""

    def __init__(self):
        """Initialize AppUpdateManager class."""
        logging.info(
            "Creating AppUpdateManager version {}".format(__version__)
        )
        self.app_mng = apm.AppManager()
        self.app_lifecycle_mng = alm.AppLifecycleManager()

    def install_and_run_package(self, package_path):
        """
        Instal and run application.

        If application exists it will first stop and delete it, and then
        Install and run it.
        :param package_path: Package path
        :return:
        """
        logging.info("Install and run package: {}".format(package_path))
        # Check if container is running and stop it
        # App id is the destination directory of a package
        app_id = ""
        try:
            app_id = self.app_mng.get_package_dest_dir(package_path)
        except subprocess.CalledProcessError as e:
            logging.exception(
                "Operation failed with return code: {}".format(e.returncode)
            )
            return Error.ERR_GET_APP_ID_FAILED
        # Check if app is running
        # Note: We use app_id as container ID
        status = self.app_lifecycle_mng.get_container_state(app_id)
        if status is alm.ContainerState.UNKNOWN:
            logging.error("Container id {} status is unknow.".format(app_id))
            return Error.ERR_GET_CONTAINER_STATUS_FAILED
        if status is not alm.ContainerState.DOES_NOT_EXIST:
            # Need to stop container
            logging.debug(
                "Container id {} exists. Stop container...".format(app_id)
            )
            result = self.app_lifecycle_mng.stop_container(
                app_id, APP_STOP_TIMEOUT
            )
            if result is not alm.Error.SUCCESS:
                logging.error(
                    "Stop container id {} failed with err: {}".format(
                        app_id, result
                    )
                )
                return Error.ERR_STOP_CONTAINER_FAILED
        # Force install package (force = remove and install)
        logging.debug("InstalL package {}...".format(package_path))
        try:
            self.app_mng.force_install_package(package_path)
        except subprocess.CalledProcessError as e:
            logging.exception(
                "Install package {} failed with return code: {}"
                    .format(package_path, e.returncode)
            )
            return Error.ERR_INSTALL_PACKAGE_FAILED
        # Run container (we use app id as container id)
        logging.debug("Run Container {}...".format(app_id))
        result = self.app_lifecycle_mng.run_container(app_id, app_id)
        if result != alm.Error.SUCCESS:
            logging.error(
                "Run container id {} failed with err: {}".format(
                    app_id, result
                )
            )
            return Error.ERR_RUN_CONTAINER_FAILED
        return Error.SUCCESS


class StoreValidFile(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        prospective_file = values
        if not os.path.isfile(prospective_file):
            raise argparse.ArgumentTypeError(
                "file: {} not found".format(prospective_file)
            )
        if not os.access(prospective_file, os.R_OK):
            raise argparse.ArgumentTypeError(
                "file: {} is not a readable file".format(prospective_file)
            )
        setattr(namespace, self.dest, os.path.abspath(prospective_file))


def get_argument_parser():
    """
    Return argument parser.

    :return: parser
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="App lifecycle manager",
    )

    parser.add_argument(
        "-i",
        "--install-package",
        metavar="INSTALL",
        required=True,
        action=StoreValidFile,
        help="Install package on device and run it, input is .ipk file path",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        help="Increase output verbosity",
        action="store_true",
    )

    return parser


def _main():
    parser = get_argument_parser()
    args = parser.parse_args()
    info_level = logging.DEBUG if args.verbose else logging.INFO

    logging.basicConfig(
        level=info_level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )
    logging.info("Starting ARM APP UPDATE MANAGER: {}".format(__version__))
    logging.info("Command line arguments:{}".format(args))

    ret = Error.ERR_OPERATION_FAILED
    try:
        app_update_manager = AppUpdateManager()
        if args.install_package:
            ret = app_update_manager.install_and_run_package(
                args.install_package
            )
    except subprocess.CalledProcessError as e:
        logging.exception(
            "Operation failed with subprocess error code: " + str(e.returncode)
        )
        return Error.ERR_OPERATION_FAILED
    except OSError:
        logging.exception("Operation failed with OSError")
        return Error.ERR_OPERATION_FAILED
    except Exception:
        logging.exception("Operation failed exception")
        return Error.ERR_OPERATION_FAILED
    if ret == Error.SUCCESS:
        logging.info("Operation successful")
    else:
        logging.error("Operation failed: {}".format(ret))
    return ret


if __name__ == "__main__":
    sys.exit(_main())
